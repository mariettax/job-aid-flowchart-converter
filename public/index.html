<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Job Aid to Flowchart Converter</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--background-color, #f2dfd9); /* Soft Pink/Beige */
            color: var(--primary-text-color, #43281e); /* Dark Brown */
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        .container {
            max-width: 90%;
            margin: 2rem auto;
            padding: 2rem;
            background-color: var(--background-color, #f2dfd9); /* Soft Pink/Beige */
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            transition: background-color 0.3s ease;
        }
        textarea {
            width: 100%;
            min-height: 200px;
            padding: 1rem;
            border: 1px solid var(--accent-text-color, #996148); /* Muted Brown/Tan */
            border-radius: 8px;
            background-color: #ffffff; /* White background for input */
            color: var(--primary-text-color, #43281e); /* Dark Brown */
            resize: vertical;
            outline: none;
            transition: border-color 0.3s ease, color 0.3s ease;
        }
        textarea:focus {
            border-color: var(--highlight-color, #ec9e7a); /* Soft Peach */
        }
        button {
            background-color: var(--accent-text-color, #996148); /* Muted Brown/Tan */
            color: #ffffff; /* White text */
            padding: 0.8rem 1.5rem;
            border-radius: 8px;
            font-weight: 600;
            transition: background-color 0.3s ease, transform 0.2s ease, color 0.3s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        button:hover {
            background-color: var(--highlight-color, #ec9e7a); /* Soft Peach */
            transform: translateY(-2px);
        }
        .color-input-group, .flowchart-type-group {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            margin-bottom: 1.5rem;
            justify-content: center;
        }
        .color-input-group > div, .flowchart-type-group > div {
            flex: 1 1 calc(50% - 0.5rem); /* Two columns on smaller screens */
            max-width: calc(50% - 0.5rem);
        }
        @media (min-width: 768px) {
            .color-input-group > div {
                flex: 1 1 calc(25% - 0.75rem); /* Four columns on larger screens */
                max-width: calc(25% - 0.75rem);
            }
            .flowchart-type-group > div {
                 flex: 1 1 auto; /* Adjust for radio buttons */
                 max-width: none;
            }
        }
        .color-input-group label, .flowchart-type-group label {
            display: block;
            margin-bottom: 0.25rem;
            font-size: 0.9em;
            color: var(--primary-text-color, #43281e);
        }
        .color-input-group input[type="color"],
        .color-input-group input[type="text"] {
            width: 100%;
            padding: 0.25rem;
            border: 1px solid var(--accent-text-color, #996148);
            border-radius: 4px;
            height: 38px; /* Standard height */
            box-sizing: border-box; /* Include padding/border in width */
        }
        .color-input-group input[type="color"] {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background-color: transparent;
            cursor: pointer;
        }
        .color-input-group input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 0;
        }
        .color-input-group input[type="color"]::-webkit-color-swatch {
            border: none;
            border-radius: 3px;
        }
        .flowchart-type-group label {
            display: inline-flex;
            align-items: center;
            margin-right: 1.5rem;
            cursor: pointer;
        }
        .flowchart-type-group input[type="radio"] {
            margin-right: 0.5rem;
            accent-color: var(--accent-text-color, #996148);
        }

        .flowchart-container {
            margin-top: 2rem;
            padding: 1.5rem;
            background-color: #fff; /* White background for flowchart elements */
            border-radius: 10px;
            border: 1px solid var(--accent-text-color, #996148);
            display: flex; /* Use flexbox for layout */
            flex-direction: column; /* Stack vertically */
            align-items: center; /* Center items horizontally */
        }

        /* Common Node Styles */
        .flowchart-node {
            padding: 1rem 1.5rem;
            margin-bottom: 1.5rem;
            text-align: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
            color: var(--primary-text-color);
            font-weight: 500;
            width: fit-content; /* Adjust width to content */
            max-width: 90%; /* Limit max width */
            border: 1px solid transparent; /* Default border */
        }

        /* Specific Node Styles */
        .node-start, .node-end {
            background-color: var(--highlight-color);
            border-radius: 9999px; /* Fully rounded for capsule shape */
            border: 1px solid var(--accent-text-color);
            padding: 0.8rem 2rem;
            font-weight: 600;
            white-space: nowrap; /* Prevent text wrapping */
        }
        .node-process {
            background-color: var(--background-color-light);
            border-radius: 8px;
            border: 1px solid var(--accent-text-color);
            padding: 1rem 1.5rem;
        }
        .node-decision {
            background-color: var(--highlight-color);
            position: relative;
            width: 150px; /* Base width for diamond */
            height: 150px; /* Base height for diamond */
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden; /* Hide overflow of rotated content */
            transform: rotate(45deg); /* Rotate to form diamond */
            margin: 2rem 0; /* Add margin for spacing */
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            border: 1px solid var(--accent-text-color);
        }
        .node-decision span {
            transform: rotate(-45deg); /* Rotate text back */
            max-width: 80%; /* Limit text width */
            word-wrap: break-word; /* Allow long words to break */
            display: block; /* Make span behave like a block for max-width */
            line-height: 1.3;
            font-weight: 600;
            font-size: 0.9em;
            color: var(--primary-text-color);
        }

        .flowchart-content-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
        }

        .flowchart-content-sequential .phase-block {
            background-color: var(--highlight-color); /* Soft Peach for phase headers */
            color: var(--primary-text-color); /* Dark Brown */
            padding: 1rem 1.5rem;
            border-radius: 8px;
            font-size: 1.4em;
            font-weight: 600;
            margin-bottom: 1.5rem;
            text-align: center;
            position: relative;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            transition: background-color 0.3s ease, color 0.3s ease;
            width: 80%; /* Make them wider */
            max-width: 600px;
        }
        .flowchart-content-sequential .step-block {
            background-color: var(--background-color-light); /* Soft Pink/Beige for step blocks */
            color: var(--primary-text-color); /* Dark Brown */
            padding: 1rem;
            border-radius: 8px;
            margin-left: 0px; /* No indent for sequential */
            margin-bottom: 1rem;
            border: 1px dashed var(--accent-text-color); /* Muted Brown/Tan dashed border */
            position: relative;
            transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
            width: 75%; /* Make them wider */
            max-width: 550px;
        }
        .flowchart-content-sequential .arrow {
            text-align: center;
            font-size: 2.5em;
            color: var(--accent-text-color); /* Muted Brown/Tan */
            margin: 10px 0;
            font-weight: bold;
            transition: color 0.3s ease;
        }

        /* Decision Flowchart specific styles */
        .flowchart-content-decision {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            gap: 1.5rem; /* Consistent spacing between nodes */
        }
        .flowchart-content-decision .decision-line {
            width: 2px;
            height: 40px;
            background-color: var(--accent-text-color);
            margin: -0.5rem auto -0.5rem auto; /* Adjust margin to connect */
            transition: background-color 0.3s ease;
        }
        .flowchart-content-decision .decision-branch-container {
            display: flex;
            justify-content: center; /* Center branches */
            width: 100%; /* Take full width to allow spacing */
            margin-top: 0rem;
            margin-bottom: 0rem;
            gap: 2rem; /* Gap between YES/NO branches */
            flex-wrap: wrap; /* Allow branches to wrap on smaller screens */
        }
        .flowchart-content-decision .decision-branch {
            display: flex;
            flex-direction: column;
            align-items: center;
            flex: 0 0 auto; /* Don't grow/shrink, base on content */
            padding: 0 10px;
            max-width: 45%; /* Prevent branches from becoming too wide */
        }
        .flowchart-content-decision .decision-label {
            background-color: var(--accent-text-color);
            color: white;
            padding: 0.2rem 0.8rem;
            border-radius: 4px;
            font-size: 0.8em;
            margin-bottom: 5px;
            font-weight: bold;
            text-transform: uppercase;
            transition: background-color 0.3s ease;
        }
        .flowchart-content-decision .decision-branch-line {
            width: 2px;
            height: 30px; /* Vertical part of branch */
            background-color: var(--accent-text-color);
            margin-top: 5px;
            transition: background-color 0.3s ease;
        }
        .flowchart-content-decision .horizontal-line {
            height: 2px;
            background-color: var(--accent-text-color);
            width: 100%; /* Spanning across branches */
            transition: background-color 0.3s ease;
        }

        .flowchart-node.decision-start {
             margin-top: 0.5rem; /* Adjust margin for start node */
             margin-bottom: 0.5rem;
        }
        .flowchart-node.decision-end {
             margin-bottom: 0.5rem; /* Adjust margin for end node */
             margin-top: 0.5rem;
        }


        .loading-spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-left-color: var(--accent-text-color);
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
            display: none; /* Hidden by default */
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .message-box {
            background-color: var(--highlight-color);
            color: var(--primary-text-color);
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
            text-align: center;
            font-weight: 500;
            display: none;
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        .message-box.error {
            background-color: #ffcccc; /* Light red */
            color: #cc0000; /* Dark red text */
        }
        .message-box.warning {
            background-color: #ffebcc; /* Light orange */
            color: #e69500; /* Dark orange text */
        }
        .download-button-container {
            display: flex;
            justify-content: center;
            margin-top: 2rem;
            padding-top: 1.5rem;
            border-top: 1px dashed var(--accent-text-color);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="text-4xl font-bold text-center mb-6">
            Job Aid to Flowchart Converter
        </h1>
        <p class="text-center mb-8">
            Paste your job aid text below and click "Generate Flowchart" to visualize its steps!
        </p>

        <!-- Color Palette Inputs -->
        <div class="color-input-group">
            <div>
                <label for="primaryTextColorInput">Primary Text Color:</label>
                <input type="color" id="primaryTextColorInput" value="#43281e">
            </div>
            <div>
                <label for="accentTextColorInput">Accent/Secondary Color:</label>
                <input type="color" id="accentTextColorInput" value="#996148">
            </div>
            <div>
                <label for="backgroundColorInput">Background Color:</label>
                <input type="color" id="backgroundColorInput" value="#f2dfd9">
            </div>
            <div>
                <label for="highlightColorInput">Highlights Color:</label>
                <input type="color" id="highlightColorInput" value="#ec9e7a">
            </div>
        </div>

        <!-- Flowchart Type Selection -->
        <div class="flowchart-type-group mb-6 p-4 rounded-lg border border-gray-300">
            <label class="text-lg font-semibold" style="color: var(--primary-text-color);">Choose Flowchart Type:</label>
            <div>
                <label for="sequentialFlowchart">
                    <input type="radio" id="sequentialFlowchart" name="flowchart_type" value="sequential" checked>
                    Sequential Process
                </label>
            </div>
            <div>
                <label for="decisionFlowchart">
                    <input type="radio" id="decisionFlowchart" name="flowchart_type" value="decision">
                    Decision-Based (Beta)
                </label>
            </div>
        </div>
        
        <textarea id="jobAidInput" placeholder="Paste your job aid text here..."></textarea>

        <div class="flex justify-center mt-6">
            <button id="generateFlowchartBtn">Generate Flowchart</button>
        </div>

        <div id="loadingSpinner" class="loading-spinner"></div>
        <div id="messageBox" class="message-box"></div>

        <div id="flowchartOutput" class="flowchart-container hidden">
            <h2 class="text-2xl font-semibold text-center mb-6" style="color: var(--primary-text-color, #43281e);">
                Your Generated Flowchart
            </h2>
            <div id="flowchartContent" class="flowchart-content-sequential">
                <!-- Flowchart will be rendered here -->
            </div>
            <div class="download-button-container">
                <button id="downloadFlowchartBtn">Download Flowchart as PNG</button>
            </div>
        </div>
    </div>

    <script type="module">
        // The firebase imports below are not strictly needed for this app's core functionality
        // (generating flowcharts via Gemini API), but are included as per general Canvas app guidelines.
        // For a deployed app on Firebase Hosting, the Canvas-specific __firebase_config and __initial_auth_token
        // are not available, causing the initialization to fail.
        // We will comment out the problematic initialization and authentication.

        // import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        // import { getAuth, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        
        const jobAidInput = document.getElementById('jobAidInput');
        const generateFlowchartBtn = document.getElementById('generateFlowchartBtn');
        const flowchartOutput = document.getElementById('flowchartOutput');
        const flowchartContent = document.getElementById('flowchartContent');
        const loadingSpinner = document.getElementById('loadingSpinner');
        const messageBox = document.getElementById('messageBox');
        const downloadFlowchartBtn = document.getElementById('downloadFlowchartBtn');

        // Color input elements
        const primaryTextColorInput = document.getElementById('primaryTextColorInput');
        const accentTextColorInput = document.getElementById('accentTextColorInput');
        const backgroundColorInput = document.getElementById('backgroundColorInput');
        const highlightColorInput = document.getElementById('highlightColorInput');

        // Flowchart type radio buttons
        const sequentialFlowchartRadio = document.getElementById('sequentialFlowchart');
        const decisionFlowchartRadio = document.getElementById('decisionFlowchart');

        // let auth; // Firebase Auth instance - no longer needed if not initializing Firebase

        // Helper function for exponential backoff
        async function fetchWithRetry(url, options, retries = 3, delay = 1000) {
            for (let i = 0; i < retries; i++) {
                try {
                    const response = await fetch(url, options);
                    if (response.ok) {
                        return response;
                    } else if (response.status === 429 && i < retries - 1) { // Too Many Requests
                        await new Promise(res => setTimeout(res, delay));
                        delay *= 2; // Exponential backoff
                    } else {
                        throw new Error(`HTTP error! Status: ${response.status}`);
                    }
                } catch (error) {
                    if (i < retries - 1) {
                        await new Promise(res => setTimeout(res, delay));
                        delay *= 2;
                    } else {
                        throw error;
                    }
                }
            }
        }

        /*
        // Original initializeFirebaseAndAuth function - commented out for deployment
        async function initializeFirebaseAndAuth() {
            try {
                const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
                const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');

                const app = initializeApp(firebaseConfig);
                auth = getAuth(app);

                // Authenticate anonymously or with custom token if provided
                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    await signInWithCustomToken(auth, __initial_auth_token);
                } else {
                    await signInAnonymously(auth);
                }
                console.log("Firebase initialized and authenticated.");
            } catch (error) {
                console.error("Error initializing Firebase or authenticating:", error);
                showMessage("Failed to initialize the app. Please try again later.", "error");
            }
        }
        */

        // Function to apply colors to CSS variables
        function applyColorsToCSS() {
            document.documentElement.style.setProperty('--primary-text-color', primaryTextColorInput.value);
            document.documentElement.style.setProperty('--accent-text-color', accentTextColorInput.value);
            document.documentElement.style.setProperty('--background-color', backgroundColorInput.value);
            document.documentElement.style.setProperty('--highlight-color', highlightColorInput.value);
            document.documentElement.style.setProperty('--background-color-light', backgroundColorInput.value); // Used for step blocks
        }

        // Event listeners for color inputs to update immediately
        primaryTextColorInput.addEventListener('input', applyColorsToCSS);
        accentTextColorInput.addEventListener('input', applyColorsToCSS);
        backgroundColorInput.addEventListener('input', applyColorsToCSS);
        highlightColorInput.addEventListener('input', applyColorsToCSS);

        // Define JSON schemas for LLM responses based on flowchart type
        const sequentialSchema = {
            type: "ARRAY",
            items: {
                type: "OBJECT",
                properties: {
                    "phaseTitle": { "type": "STRING" },
                    "steps": {
                        type: "ARRAY",
                        items: {
                            type: "OBJECT",
                            properties: {
                                "stepTitle": { "type": "STRING" },
                                "descriptionPoints": {
                                    "type": "ARRAY",
                                    "items": { "type": "STRING" }
                                }
                            },
                            propertyOrdering: ["stepTitle", "descriptionPoints"]
                        }
                    }
                },
                propertyOrdering: ["phaseTitle", "steps"]
            }
        };

        // Simplified schema for decision-based flowchart (nodes and connections are inferred/basic)
        const decisionSchema = {
            type: "ARRAY",
            items: {
                type: "OBJECT",
                properties: {
                    "type": { "type": "STRING", "enum": ["start", "process", "decision", "end"] },
                    "text": { "type": "STRING" },
                    "yesOutcome": { "type": "STRING", "nullable": true }, // Description of what happens on YES
                    "noOutcome": { "type": "STRING", "nullable": true },  // Description of what happens on NO
                },
                // No 'children' as it complicates schema and isn't used for visual connections in this layout
                propertyOrdering: ["type", "text", "yesOutcome", "noOutcome"]
            }
        };


        async function generateFlowchart() {
            const jobAidText = jobAidInput.value.trim();
            if (!jobAidText) {
                showMessage("Please enter your job aid text.", "warning");
                return;
            }

            loadingSpinner.style.display = 'block';
            generateFlowchartBtn.disabled = true;
            downloadFlowchartBtn.disabled = true; // Disable download during generation
            flowchartOutput.classList.add('hidden');
            showMessage("", ""); // Clear previous messages

            try {
                applyColorsToCSS(); // Ensure colors are applied before rendering

                let prompt = "";
                let schemaToUse = {};
                const flowchartType = document.querySelector('input[name="flowchart_type"]:checked').value;

                if (flowchartType === 'sequential') {
                    prompt = `Convert the following job aid text into a structured sequential process flowchart format. Identify distinct phases, steps within each phase, and concise bullet points describing each step. Focus on clarity and logical flow.

Job Aid Text:
"${jobAidText}"

Provide the output as a JSON array where each object represents a phase, containing a 'phaseTitle' and an array of 'steps'. Each 'step' object should have a 'stepTitle' and an array of 'descriptionPoints'.`;
                    schemaToUse = sequentialSchema;
                    flowchartContent.className = 'flowchart-content-sequential'; // Apply sequential specific styles
                } else { // decision
                    // Modified prompt to better guide the AI for decision flowcharts
                    prompt = `Analyze the following text describing a process. Extract key elements to form a decision-based flowchart.
                    Identify:
                    - A single "start" point.
                    - "process" steps (actions to be taken).
                    - "decision" points (questions that lead to different paths). For each decision, provide a "yesOutcome" and a "noOutcome" that describe the immediate next step or action for each path.
                    - "end" points (conclusions of paths).

                    Represent this as a flat JSON array of nodes. Each node should have a 'type' ("start", "process", "decision", "end") and 'text'. If the type is "decision", include 'yesOutcome' and 'noOutcome'. The order of nodes in the array should represent a general top-to-bottom flow, with decision outcomes described inline.

                    Text:
                    "${jobAidText}"`;
                    schemaToUse = decisionSchema;
                    flowchartContent.className = 'flowchart-content-decision'; // Apply decision specific styles
                }

                const chatHistory = [{ role: "user", parts: [{ text: prompt }] }];
                const payload = {
                    contents: chatHistory,
                    generationConfig: {
                        responseMimeType: "application/json",
                        responseSchema: schemaToUse
                    }
                };

                const apiKey = "AIzaSyBq3RUbFNCiadA4jx54SRIpUufNYCqVdVk"; // Canvas will automatically provide this
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;

                const response = await fetchWithRetry(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const result = await response.json();
                console.log("API Raw Result:", result); // Log raw API result for debugging

                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const jsonString = result.candidates[0].content.parts[0].text;
                    console.log("JSON String from API:", jsonString); // Log JSON string before parsing
                    
                    let flowchartData;
                    try {
                        flowchartData = JSON.parse(jsonString);
                        console.log("Parsed Flowchart Data:", flowchartData); // Log parsed data
                    } catch (parseError) {
                        console.error("JSON Parsing Error:", parseError);
                        showMessage("Error parsing AI response. The generated format was not valid JSON. Please try again or simplify your input.", "error");
                        return; // Exit if parsing failed
                    }

                    if (flowchartType === 'sequential') {
                        renderSequentialFlowchart(flowchartData);
                    } else {
                        renderDecisionFlowchart(flowchartData);
                    }
                    flowchartOutput.classList.remove('hidden');
                    downloadFlowchartBtn.disabled = false; // Enable download after successful rendering
                } else {
                    showMessage("Could not generate flowchart. The AI response was empty or malformed. Please try rephrasing your job aid.", "error");
                    console.error("AI response was empty or malformed:", result);
                }

            } catch (error) {
                console.error("Error generating flowchart:", error);
                showMessage("An error occurred while generating the flowchart. Please check the console for more details.", "error");
            } finally {
                loadingSpinner.style.display = 'none';
                generateFlowchartBtn.disabled = false;
            }
        }

        // --- Rendering Functions ---

        function renderSequentialFlowchart(data) {
            flowchartContent.innerHTML = ''; // Clear previous content
            if (!Array.isArray(data) || data.length === 0) {
                showMessage("No sequential flowchart data generated. Please ensure your job aid has clear steps/phases.", "warning");
                return;
            }

            data.forEach((phase, index) => {
                const phaseBlock = document.createElement('div');
                phaseBlock.className = 'phase-block';
                phaseBlock.textContent = phase.phaseTitle;
                flowchartContent.appendChild(phaseBlock);

                if (phase.steps && Array.isArray(phase.steps) && phase.steps.length > 0) {
                    phase.steps.forEach(step => {
                        const stepBlock = document.createElement('div');
                        stepBlock.className = 'step-block';

                        const stepTitle = document.createElement('h4');
                        stepTitle.className = 'font-semibold text-lg mb-1';
                        stepTitle.textContent = step.stepTitle;
                        stepBlock.appendChild(stepTitle);

                        if (step.descriptionPoints && Array.isArray(step.descriptionPoints) && step.descriptionPoints.length > 0) {
                            const ul = document.createElement('ul');
                            ul.className = 'list-disc ml-5 text-sm';
                            step.descriptionPoints.forEach(point => {
                                const li = document.createElement('li');
                                li.textContent = point;
                                ul.appendChild(li);
                            });
                            stepBlock.appendChild(ul);
                        }
                        flowchartContent.appendChild(stepBlock);
                    });
                } else {
                    const noSteps = document.createElement('p');
                    noSteps.className = 'text-center text-sm italic mb-4';
                    noSteps.style.color = 'var(--accent-text-color)';
                    noSteps.textContent = 'No detailed steps for this phase.';
                    flowchartContent.appendChild(noSteps);
                }

                if (index < data.length - 1) {
                    const arrow = document.createElement('div');
                    arrow.className = 'arrow';
                    arrow.innerHTML = '&#x2193;'; // Down arrow character
                    flowchartContent.appendChild(arrow);
                }
            });
        }

        function renderDecisionFlowchart(data) {
            flowchartContent.innerHTML = ''; // Clear previous content
            if (!Array.isArray(data) || data.length === 0) {
                showMessage("No decision flowchart data generated. Please ensure your text describes a process with clear steps and decisions (e.g., questions with YES/NO outcomes).", "warning");
                return;
            }

            data.forEach((node, index) => {
                let nodeElement;
                if (node.type === 'start') {
                    nodeElement = document.createElement('div');
                    nodeElement.className = 'flowchart-node node-start';
                    nodeElement.textContent = node.text;
                } else if (node.type === 'process') {
                    nodeElement = document.createElement('div');
                    nodeElement.className = 'flowchart-node node-process';
                    nodeElement.textContent = node.text;
                } else if (node.type === 'decision') {
                    nodeElement = document.createElement('div');
                    nodeElement.className = 'flowchart-node node-decision';
                    const span = document.createElement('span');
                    span.textContent = node.text;
                    nodeElement.appendChild(span);
                } else if (node.type === 'end') {
                    nodeElement = document.createElement('div');
                    nodeElement.className = 'flowchart-node node-end';
                    nodeElement.textContent = node.text;
                }

                if (nodeElement) {
                    flowchartContent.appendChild(nodeElement);

                    // Add connection lines and labels for decision nodes
                    if (node.type === 'decision') {
                        const branchContainer = document.createElement('div');
                        branchContainer.className = 'decision-branch-container';

                        // YES Branch
                        const yesBranch = document.createElement('div');
                        yesBranch.className = 'decision-branch';
                        const yesLabel = document.createElement('div');
                        yesLabel.className = 'decision-label';
                        yesLabel.textContent = 'YES';
                        yesBranch.appendChild(yesLabel);
                        const yesLine = document.createElement('div');
                        yesLine.className = 'decision-branch-line';
                        yesBranch.appendChild(yesLine);
                        const yesText = document.createElement('div');
                        yesText.className = 'flowchart-node node-process'; // Represent outcome as a process step
                        yesText.textContent = node.yesOutcome || 'No defined YES outcome';
                        yesBranch.appendChild(yesText);
                        branchContainer.appendChild(yesBranch);

                        // NO Branch
                        const noBranch = document.createElement('div');
                        noBranch.className = 'decision-branch';
                        const noLabel = document.createElement('div');
                        noLabel.className = 'decision-label';
                        noLabel.textContent = 'NO';
                        noBranch.appendChild(noLabel);
                        const noLine = document.createElement('div');
                        noLine.className = 'decision-branch-line';
                        noBranch.appendChild(noLine);
                        const noText = document.createElement('div');
                        noText.className = 'flowchart-node node-process'; // Represent outcome as a process step
                        noText.textContent = node.noOutcome || 'No defined NO outcome';
                        noBranch.appendChild(noText);
                        branchContainer.appendChild(noBranch);

                        flowchartContent.appendChild(branchContainer);
                    } else if (node.type !== 'end' && index < data.length - 1) {
                         // Add a line below non-end nodes (except decision, which has its own branching lines)
                        const line = document.createElement('div');
                        line.className = 'decision-line';
                        flowchartContent.appendChild(line);
                    }
                }
            });
        }


        function showMessage(message, type) {
            if (message) {
                messageBox.textContent = message;
                messageBox.className = `message-box block ${type}`; // Add type for specific styling
            } else {
                messageBox.textContent = '';
                messageBox.className = `message-box hidden`;
            }
        }

        async function downloadFlowchart() {
            // Temporarily hide the download button to not include it in the screenshot
            downloadFlowchartBtn.style.display = 'none';
            
            // Re-apply original background for `body` before screenshot if necessary
            // Or ensure the `flowchartOutput` container has a solid background
            const originalBodyBg = document.body.style.backgroundColor;
            document.body.style.backgroundColor = 'white'; // Ensure a clean background for screenshot if container is transparent

            try {
                // Capture the entire flowchartOutput div
                const canvas = await html2canvas(flowchartOutput, {
                    scale: 2, // Increase scale for better resolution
                    useCORS: true, // Necessary if any images or external resources are involved (though not in this current app)
                    backgroundColor: '#ffffff' // Ensure white background for the output image if container is transparent
                });

                // Create an image URL from the canvas
                const imageUrl = canvas.toDataURL('image/png');

                // Create a temporary link element and trigger download
                const link = document.createElement('a');
                link.href = imageUrl;
                link.download = 'job_aid_flowchart.png';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                showMessage("Flowchart downloaded successfully!", "");
            } catch (error) {
                console.error("Error downloading flowchart:", error);
                showMessage("Failed to download flowchart. Please try again or use your browser's screenshot function.", "error");
            } finally {
                // Restore the download button visibility
                downloadFlowchartBtn.style.display = 'block';
                document.body.style.backgroundColor = originalBodyBg; // Restore body background
            }
        }


        // Event listeners
        generateFlowchartBtn.addEventListener('click', generateFlowchart);
        downloadFlowchartBtn.addEventListener('click', downloadFlowchart);

        // Initialize Firebase and apply initial colors when the window loads
        window.onload = () => {
            // initializeFirebaseAndAuth(); // Removed for deployment on Firebase Hosting
            applyColorsToCSS(); // Apply default colors on load
        };
    </script>
</body>
</html>
